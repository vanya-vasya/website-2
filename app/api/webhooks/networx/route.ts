import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import prismadb from '@/lib/prismadb';

/**
 * Networx Payment Webhook Handler
 * 
 * DATA SEPARATION POLICY:
 * ========================
 * 1. Transaction table: Stores ALL transaction data (payments, refunds, etc.)
 * 2. User table: Stores ONLY user profile and token balance (availableGenerations, usedGenerations)
 * 3. Users are created ONLY via Clerk webhook (user.created event)
 * 4. Payment webhook ONLY updates existing users' balance
 * 5. All transaction writes go exclusively to Transaction table with idempotency (webhookEventId)
 * 
 * IMPORTANT RULES:
 * - Never create users in payment webhook
 * - Never store transaction data in User table
 * - Always check idempotency before processing
 * - Only update User table for balance changes on successful payments
 */

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∏ webhook —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Networx
function verifyWebhookSignature(data: Record<string, any>, signature: string, secretKey: string): boolean {
  // –£–¥–∞–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å –∏–∑ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏
  const { signature: _, ...dataForSignature } = data;

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ –∫–ª—é—á—É
  const sortedParams = Object.keys(dataForSignature)
    .sort()
    .reduce((obj: Record<string, any>, key) => {
      obj[key] = dataForSignature[key];
      return obj;
    }, {});

  // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–¥–ø–∏—Å–∏
  const signString = Object.entries(sortedParams)
    .map(([key, value]) => `${key}=${value}`)
    .join('&');

  // –°–æ–∑–¥–∞–µ–º –ø–æ–¥–ø–∏—Å—å HMAC SHA256
  const expectedSignature = crypto
    .createHmac('sha256', secretKey)
    .update(signString)
    .digest('hex');

  return expectedSignature === signature;
}

// –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞
function extractTokensFromDescription(description: string): number | null {
  const match = description.match(/\((\d+)\s+Tokens?\)/i);
  return match ? parseInt(match[1], 10) : null;
}

// POST - –û–±—Ä–∞–±–æ—Ç–∫–∞ webhook —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç Networx
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  let transactionId: string | undefined;
  let userId: string | undefined;
  
  try {
    const body = await request.json();
    
    const { 
      status, 
      order_id, 
      transaction_id, 
      amount, 
      currency, 
      type,
      customer_email,
      error_message,
      tracking_id,
      description,
      payment_method_type,
      message,
      paid_at
    } = body;

    transactionId = transaction_id;
    userId = tracking_id;

    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üì• Networx Webhook Received');
    console.log('Timestamp:', new Date().toISOString());
    console.log('Transaction ID:', transaction_id);
    console.log('Order ID:', order_id);
    console.log('Status:', status);
    console.log('Type:', type);
    console.log('Amount:', amount, currency);
    console.log('Tracking ID (User ID):', tracking_id);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    const secretKey = process.env.NETWORX_SECRET_KEY || 'dbfb6f4e977f49880a6ce3c939f1e7be645a5bb2596c04d9a3a7b32d52378950';
    if (!secretKey) {
      console.error('‚ùå NETWORX_SECRET_KEY not configured');
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      );
    }

    // –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å—å webhook
    const signature = body.signature;
    if (!signature) {
      console.error('‚ùå Missing signature in webhook');
      return NextResponse.json(
        { error: 'Missing signature' },
        { status: 400 }
      );
    }

    const isValidSignature = verifyWebhookSignature(body, signature, secretKey);
    if (!isValidSignature) {
      console.error('‚ùå Invalid webhook signature');
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 403 }
      );
    }

    console.log('‚úÖ Webhook signature verified');

    // –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã —á–µ—Ä–µ–∑ webhookEventId
    if (transaction_id) {
      const existingTransaction = await prismadb.transaction.findUnique({
        where: {
          webhookEventId: transaction_id
        }
      });

      if (existingTransaction) {
        console.log('‚ö†Ô∏è  Duplicate webhook detected - transaction already processed:', transaction_id);
        return NextResponse.json({ 
          status: 'ok',
          message: 'Transaction already processed',
          idempotent: true
        }, { status: 200 });
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç—É—Å–æ–≤ —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Networx
    switch (status) {
      case 'success':
      case 'successful':
        console.log(`üí∞ Processing successful payment for order ${order_id}`);
        
        if (!tracking_id) {
          console.error('‚ùå Missing tracking_id (userId) in successful payment webhook');
          return NextResponse.json(
            { error: 'Missing tracking_id for successful payment' },
            { status: 400 }
          );
        }

        // CRITICAL: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        // –ú—ã –ù–ï —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ webhook –ø–ª–∞—Ç–µ–∂–µ–π
        // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω—ã —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ Clerk webhook
        const user = await prismadb.user.findUnique({
          where: {
            clerkId: tracking_id,
          },
          select: {
            id: true,
            clerkId: true,
            email: true,
            usedGenerations: true,
            availableGenerations: true,
          },
        });

        if (!user) {
          console.error('‚ùå User not found:', tracking_id);
          console.error('‚ö†Ô∏è  Payment received for non-existent user. User must be created via Clerk webhook first.');
          return NextResponse.json(
            { 
              error: 'User not found',
              message: 'User must be created before processing payments' 
            },
            { status: 404 }
          );
        }

        console.log('‚úÖ User found:', user.email);
        console.log('Current balance:', user.availableGenerations);
        console.log('Used generations:', user.usedGenerations);

        // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è
        const tokensToAdd = description ? extractTokensFromDescription(description) : null;
        
        if (!tokensToAdd) {
          console.error('‚ùå Could not extract token amount from description:', description);
          return NextResponse.json(
            { error: 'Invalid payment description format' },
            { status: 400 }
          );
        }

        console.log('üéüÔ∏è  Tokens to add:', tokensToAdd);

        // –í—ã–ø–æ–ª–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        // –í–ê–ñ–ù–û: –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è—Ö –∏–¥—É—Ç –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction
        // –í —Ç–∞–±–ª–∏—Ü–µ User –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –¢–û–õ–¨–ö–û –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤ (availableGenerations, usedGenerations)
        try {
          await prismadb.$transaction(async (tx) => {
            // 1. –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ Transaction
            const newTransaction = await tx.transaction.create({
              data: {
                tracking_id: transaction_id || tracking_id,
                userId: tracking_id, // Clerk user ID –¥–ª—è —Å–≤—è–∑–∏
                status: 'successful',
                amount: amount ? parseInt(amount) : null,
                currency: currency || 'USD',
                description: description || `Payment for ${tokensToAdd} tokens`,
                type: type || 'payment',
                payment_method_type: payment_method_type || 'card',
                message: message || 'Payment successful',
                paid_at: paid_at ? new Date(paid_at) : new Date(),
                receipt_url: null,
                webhookEventId: transaction_id, // –î–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
              },
            });

            console.log('‚úÖ Transaction record created in Transaction table:', newTransaction.id);
            console.log('   Transaction ID:', transaction_id);
            console.log('   Amount:', amount, currency);
            console.log('   Tokens:', tokensToAdd);

            // 2. –û–±–Ω–æ–≤–ª—è–µ–º –¢–û–õ–¨–ö–û –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ù–ï —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
            // User table —Å–æ–¥–µ—Ä–∂–∏—Ç –¢–û–õ–¨–ö–û –ø—Ä–æ—Ñ–∏–ª—å –∏ –±–∞–ª–∞–Ω—Å, –ù–ï –¥–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
            const updatedUser = await tx.user.update({
              where: {
                clerkId: tracking_id,
              },
              data: {
                // –§–æ—Ä–º—É–ª–∞: –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å = —Ç–µ–∫—É—â–∏–π –¥–æ—Å—Ç—É–ø–Ω—ã–π - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π + –∫—É–ø–ª–µ–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
                availableGenerations: user.availableGenerations - user.usedGenerations + tokensToAdd,
                usedGenerations: 0, // –°–±—Ä–æ—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è
              },
            });

            console.log('‚úÖ User balance updated in User table');
            console.log('   Previous balance:', user.availableGenerations);
            console.log('   Used generations:', user.usedGenerations);
            console.log('   New available generations:', updatedUser.availableGenerations);
            console.log('   Reset used generations:', updatedUser.usedGenerations);
          });

          const processingTime = Date.now() - startTime;
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          console.log('‚úÖ Payment processed successfully');
          console.log('Processing time:', processingTime, 'ms');
          console.log('User ID:', tracking_id);
          console.log('Transaction ID:', transaction_id);
          console.log('Tokens added:', tokensToAdd);
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

        } catch (dbError) {
          console.error('‚ùå Database transaction failed:', dbError);
          throw dbError;
        }

        break;

      case 'failed':
        console.log(`‚ùå Payment failed for order ${order_id}`);
        console.log('Error message:', error_message);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction, –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º User
        if (transaction_id) {
          await prismadb.transaction.create({
            data: {
              tracking_id: transaction_id,
              userId: tracking_id || null,
              status: 'failed',
              amount: amount ? parseInt(amount) : null,
              currency: currency || 'USD',
              description: description || 'Payment failed',
              type: type || 'payment',
              payment_method_type: payment_method_type || 'card',
              message: error_message || 'Payment failed',
              reason: error_message,
              webhookEventId: transaction_id,
            },
          });
          console.log('‚úÖ Failed transaction record created in Transaction table');
        }
        break;

      case 'pending':
        console.log(`‚è≥ Payment pending for order ${order_id}`);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction, –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º User
        if (transaction_id) {
          await prismadb.transaction.create({
            data: {
              tracking_id: transaction_id,
              userId: tracking_id || null,
              status: 'pending',
              amount: amount ? parseInt(amount) : null,
              currency: currency || 'USD',
              description: description || 'Payment pending',
              type: type || 'payment',
              payment_method_type: payment_method_type || 'card',
              message: message || 'Payment pending',
              webhookEventId: transaction_id,
            },
          });
          console.log('‚úÖ Pending transaction record created in Transaction table');
        }
        break;

      case 'canceled':
        console.log(`üö´ Payment canceled for order ${order_id}`);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction, –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º User
        if (transaction_id) {
          await prismadb.transaction.create({
            data: {
              tracking_id: transaction_id,
              userId: tracking_id || null,
              status: 'canceled',
              amount: amount ? parseInt(amount) : null,
              currency: currency || 'USD',
              description: description || 'Payment canceled',
              type: type || 'payment',
              payment_method_type: payment_method_type || 'card',
              message: message || 'Payment canceled',
              webhookEventId: transaction_id,
            },
          });
          console.log('‚úÖ Canceled transaction record created in Transaction table');
        }
        break;

      case 'refunded':
        console.log(`üí∞ Payment refunded for order ${order_id}`);
        
        if (transaction_id && tracking_id) {
          // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞
          const tokensToRefund = description ? extractTokensFromDescription(description) : null;
          
          if (tokensToRefund) {
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–æ–∑–≤—Ä–∞—Ç –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            await prismadb.$transaction(async (tx) => {
              // 1. –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –≤–æ–∑–≤—Ä–∞—Ç–µ –≤ Transaction table
              await tx.transaction.create({
                data: {
                  tracking_id: transaction_id,
                  userId: tracking_id,
                  status: 'refunded',
                  amount: amount ? parseInt(amount) : null,
                  currency: currency || 'USD',
                  description: description || 'Payment refunded',
                  type: 'refund',
                  payment_method_type: payment_method_type || 'card',
                  message: message || 'Payment refunded',
                  webhookEventId: transaction_id,
                },
              });
              console.log('‚úÖ Refund transaction record created in Transaction table');

              // 2. –í—ã—á–∏—Ç–∞–µ–º —Ç–æ–∫–µ–Ω—ã –∏–∑ –±–∞–ª–∞–Ω—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¢–û–õ–¨–ö–û –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞)
              const user = await tx.user.findUnique({
                where: { clerkId: tracking_id },
                select: { availableGenerations: true }
              });

              if (user) {
                await tx.user.update({
                  where: { clerkId: tracking_id },
                  data: {
                    // –í—ã—á–∏—Ç–∞–µ–º –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã, –Ω–æ –Ω–µ —É—Ö–æ–¥–∏–º –≤ –º–∏–Ω—É—Å
                    availableGenerations: Math.max(0, user.availableGenerations - tokensToRefund),
                  },
                });
                console.log('‚úÖ User balance adjusted for refund in User table');
                console.log('   Tokens refunded:', tokensToRefund);
                console.log('   New balance:', Math.max(0, user.availableGenerations - tokensToRefund));
              }
            });
          }
        }
        break;

      default:
        console.log(`‚ùì Unknown payment status: ${status} for order ${order_id}`);
    }

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º Networx
    return NextResponse.json({ status: 'ok' }, { status: 200 });

  } catch (error) {
    const processingTime = Date.now() - startTime;
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.error('‚ùå Webhook Processing Error');
    console.error('Timestamp:', new Date().toISOString());
    console.error('Processing time:', processingTime, 'ms');
    console.error('Transaction ID:', transactionId);
    console.error('User ID:', userId);
    console.error('Error:', error);
    console.error('Stack:', error instanceof Error ? error.stack : 'No stack trace');
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}

// GET - –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ endpoint'–∞
export async function GET() {
  return NextResponse.json({
    message: 'Networx webhook endpoint is active',
    timestamp: new Date().toISOString(),
  });
}
