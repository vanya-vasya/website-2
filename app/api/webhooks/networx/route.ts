import { NextRequest, NextResponse } from 'next/server';
import crypto from 'crypto';
import prismadb from '@/lib/prismadb';
import { transporter } from '@/config/nodemailer';
import { generatePdfReceipt } from '@/lib/receiptGeneration';

/**
 * Networx Payment Webhook Handler
 * 
 * DATA SEPARATION POLICY:
 * ========================
 * 1. Transaction table: Stores ALL transaction data (payments, refunds, etc.)
 * 2. User table: Stores ONLY user profile and token balance (availableGenerations, usedGenerations)
 * 3. Users are created ONLY via Clerk webhook (user.created event)
 * 4. Payment webhook ONLY updates existing users' balance
 * 5. All transaction writes go exclusively to Transaction table with idempotency (webhookEventId)
 * 
 * IMPORTANT RULES:
 * - Never create users in payment webhook
 * - Never store transaction data in User table
 * - Always check idempotency before processing
 * - Only update User table for balance changes on successful payments
 * - Generate and email PDF receipts for successful payments
 * - Use tracking_id for idempotency checks (primary)
 * - Use webhookEventId as fallback idempotency check
 */

// –§—É–Ω–∫—Ü–∏—è –¥–ª—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏ –ø–æ–¥–ø–∏—Å–∏ webhook —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Networx
function verifyWebhookSignature(data: Record<string, any>, signature: string, secretKey: string): boolean {
  // –£–¥–∞–ª—è–µ–º –ø–æ–¥–ø–∏—Å—å –∏–∑ –¥–∞–Ω–Ω—ã—Ö –¥–ª—è –≤–µ—Ä–∏—Ñ–∏–∫–∞—Ü–∏–∏
  const { signature: _, ...dataForSignature } = data;

  // –°–æ—Ä—Ç–∏—Ä—É–µ–º –ø–∞—Ä–∞–º–µ—Ç—Ä—ã –ø–æ –∫–ª—é—á—É
  const sortedParams = Object.keys(dataForSignature)
    .sort()
    .reduce((obj: Record<string, any>, key) => {
      obj[key] = dataForSignature[key];
      return obj;
    }, {});

  // –°–æ–∑–¥–∞–µ–º —Å—Ç—Ä–æ–∫—É –¥–ª—è –ø–æ–¥–ø–∏—Å–∏
  const signString = Object.entries(sortedParams)
    .map(([key, value]) => `${key}=${value}`)
    .join('&');

  // –°–æ–∑–¥–∞–µ–º –ø–æ–¥–ø–∏—Å—å HMAC SHA256
  const expectedSignature = crypto
    .createHmac('sha256', secretKey)
    .update(signString)
    .digest('hex');

  return expectedSignature === signature;
}

// –ò–∑–≤–ª–µ—á–µ–Ω–∏–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è –ø–ª–∞—Ç–µ–∂–∞
function extractTokensFromDescription(description: string): number | null {
  const match = description.match(/\((\d+)\s+Tokens?\)/i);
  return match ? parseInt(match[1], 10) : null;
}

// POST - –û–±—Ä–∞–±–æ—Ç–∫–∞ webhook —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–π –æ—Ç Networx
export async function POST(request: NextRequest) {
  const startTime = Date.now();
  let transactionId: string | undefined;
  let userId: string | undefined;
  
  try {
    const body = await request.json();
    
    const { 
      status, 
      order_id, 
      transaction_id, 
      amount, 
      currency, 
      type,
      customer_email,
      error_message,
      tracking_id,
      description,
      payment_method_type,
      message,
      paid_at
    } = body;

    transactionId = transaction_id;
    userId = tracking_id;

    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.log('üì• Networx Webhook Received');
    console.log('Timestamp:', new Date().toISOString());
    console.log('Transaction ID:', transaction_id);
    console.log('Order ID:', order_id);
    console.log('Status:', status);
    console.log('Type:', type);
    console.log('Amount:', amount, currency);
    console.log('Tracking ID (User ID):', tracking_id);
    console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

    const secretKey = process.env.NETWORX_SECRET_KEY || 'dbfb6f4e977f49880a6ce3c939f1e7be645a5bb2596c04d9a3a7b32d52378950';
    if (!secretKey) {
      console.error('‚ùå NETWORX_SECRET_KEY not configured');
      return NextResponse.json(
        { error: 'Server configuration error' },
        { status: 500 }
      );
    }

    // –í–µ—Ä–∏—Ñ–∏—Ü–∏—Ä—É–µ–º –ø–æ–¥–ø–∏—Å—å webhook
    const signature = body.signature;
    if (!signature) {
      console.error('‚ùå Missing signature in webhook');
      return NextResponse.json(
        { error: 'Missing signature' },
        { status: 400 }
      );
    }

    const isValidSignature = verifyWebhookSignature(body, signature, secretKey);
    if (!isValidSignature) {
      console.error('‚ùå Invalid webhook signature');
      return NextResponse.json(
        { error: 'Invalid signature' },
        { status: 403 }
      );
    }

    console.log('‚úÖ Webhook signature verified');

    // –ò–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç—å: –ü—Ä–æ–≤–µ—Ä–∫–∞ –Ω–∞ –¥—É–±–ª–∏–∫–∞—Ç—ã —á–µ—Ä–µ–∑ tracking_id (PRIMARY) –∏ webhookEventId (FALLBACK)
    if (transaction_id) {
      // Check using tracking_id first (more reliable for idempotency)
      const existingByTrackingId = await prismadb.transaction.findUnique({
        where: {
          tracking_id: transaction_id
        }
      });

      if (existingByTrackingId) {
        console.log('‚ö†Ô∏è  Duplicate webhook detected (via tracking_id) - transaction already processed:', transaction_id);
        return NextResponse.json({ 
          status: 'ok',
          message: 'Transaction already processed',
          idempotent: true,
          method: 'tracking_id'
        }, { status: 200 });
      }

      // Fallback: Check using webhookEventId
      const existingByWebhookId = await prismadb.transaction.findUnique({
        where: {
          webhookEventId: transaction_id
        }
      });

      if (existingByWebhookId) {
        console.log('‚ö†Ô∏è  Duplicate webhook detected (via webhookEventId) - transaction already processed:', transaction_id);
        return NextResponse.json({ 
          status: 'ok',
          message: 'Transaction already processed',
          idempotent: true,
          method: 'webhookEventId'
        }, { status: 200 });
      }
    }

    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Å—Ç–∞—Ç—É—Å–æ–≤ —Å–æ–≥–ª–∞—Å–Ω–æ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ Networx
    switch (status) {
      case 'success':
      case 'successful':
        console.log(`üí∞ Processing successful payment for order ${order_id}`);
        
        if (!tracking_id) {
          console.error('‚ùå Missing tracking_id (userId) in successful payment webhook');
          return NextResponse.json(
            { error: 'Missing tracking_id for successful payment' },
            { status: 400 }
          );
        }

        // CRITICAL: –ü—Ä–æ–≤–µ—Ä—è–µ–º —Å—É—â–µ—Å—Ç–≤–æ–≤–∞–Ω–∏–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è
        // –ú—ã –ù–ï —Å–æ–∑–¥–∞–µ–º –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –≤ webhook –ø–ª–∞—Ç–µ–∂–µ–π
        // –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –¥–æ–ª–∂–Ω—ã –±—ã—Ç—å —Å–æ–∑–¥–∞–Ω—ã —Ç–æ–ª—å–∫–æ —á–µ—Ä–µ–∑ Clerk webhook
        const user = await prismadb.user.findUnique({
          where: {
            clerkId: tracking_id,
          },
          select: {
            id: true,
            clerkId: true,
            email: true,
            usedGenerations: true,
            availableGenerations: true,
          },
        });

        if (!user) {
          console.error('‚ùå User not found:', tracking_id);
          console.error('‚ö†Ô∏è  Payment received for non-existent user. User must be created via Clerk webhook first.');
          return NextResponse.json(
            { 
              error: 'User not found',
              message: 'User must be created before processing payments' 
            },
            { status: 404 }
          );
        }

        console.log('‚úÖ User found:', user.email);
        console.log('Current balance:', user.availableGenerations);
        console.log('Used generations:', user.usedGenerations);

        // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –∏–∑ –æ–ø–∏—Å–∞–Ω–∏—è
        const tokensToAdd = description ? extractTokensFromDescription(description) : null;
        
        if (!tokensToAdd) {
          console.error('‚ùå Could not extract token amount from description:', description);
          return NextResponse.json(
            { error: 'Invalid payment description format' },
            { status: 400 }
          );
        }

        console.log('üéüÔ∏è  Tokens to add:', tokensToAdd);

        // –í—ã–ø–æ–ª–Ω—è–µ–º –æ–ø–µ—Ä–∞—Ü–∏–∏ –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
        // –í–ê–ñ–ù–û: –í—Å–µ –¥–∞–Ω–Ω—ã–µ –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—è—Ö –∏–¥—É—Ç –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction
        // –í —Ç–∞–±–ª–∏—Ü–µ User –æ–±–Ω–æ–≤–ª—è–µ—Ç—Å—è –¢–û–õ–¨–ö–û –±–∞–ª–∞–Ω—Å —Ç–æ–∫–µ–Ω–æ–≤ (availableGenerations, usedGenerations)
        try {
          await prismadb.$transaction(async (tx) => {
            // 1. –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏ –≤ —Ç–∞–±–ª–∏—Ü–µ Transaction
            const newTransaction = await tx.transaction.create({
              data: {
                tracking_id: transaction_id || tracking_id,
                userId: tracking_id, // Clerk user ID –¥–ª—è —Å–≤—è–∑–∏
                status: 'successful',
                amount: amount ? parseInt(amount) : null,
                currency: currency || 'USD',
                description: description || `Payment for ${tokensToAdd} tokens`,
                type: type || 'payment',
                payment_method_type: payment_method_type || 'card',
                message: message || 'Payment successful',
                paid_at: paid_at ? new Date(paid_at) : new Date(),
                receipt_url: null,
                webhookEventId: transaction_id, // –î–ª—è –∏–¥–µ–º–ø–æ—Ç–µ–Ω—Ç–Ω–æ—Å—Ç–∏
              },
            });

            console.log('‚úÖ Transaction record created in Transaction table:', newTransaction.id);
            console.log('   Transaction ID:', transaction_id);
            console.log('   Amount:', amount, currency);
            console.log('   Tokens:', tokensToAdd);

            // 2. –û–±–Ω–æ–≤–ª—è–µ–º –¢–û–õ–¨–ö–û –±–∞–ª–∞–Ω—Å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–ù–ï —Å–æ–∑–¥–∞–µ–º –Ω–æ–≤–æ–≥–æ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è)
            // User table —Å–æ–¥–µ—Ä–∂–∏—Ç –¢–û–õ–¨–ö–û –ø—Ä–æ—Ñ–∏–ª—å –∏ –±–∞–ª–∞–Ω—Å, –ù–ï –¥–∞–Ω–Ω—ã–µ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–π
            const updatedUser = await tx.user.update({
              where: {
                clerkId: tracking_id,
              },
              data: {
                // –§–æ—Ä–º—É–ª–∞: –Ω–æ–≤—ã–π –±–∞–ª–∞–Ω—Å = —Ç–µ–∫—É—â–∏–π –¥–æ—Å—Ç—É–ø–Ω—ã–π - –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã–π + –∫—É–ø–ª–µ–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã
                availableGenerations: user.availableGenerations - user.usedGenerations + tokensToAdd,
                usedGenerations: 0, // –°–±—Ä–æ—Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–Ω—ã—Ö –ø–æ—Å–ª–µ –ø–æ–ø–æ–ª–Ω–µ–Ω–∏—è
              },
            });

            console.log('‚úÖ User balance updated in User table');
            console.log('   Previous balance:', user.availableGenerations);
            console.log('   Used generations:', user.usedGenerations);
            console.log('   New available generations:', updatedUser.availableGenerations);
            console.log('   Reset used generations:', updatedUser.usedGenerations);
          });

          // Generate and send receipt email
          try {
            console.log('üìß Generating PDF receipt and sending email...');
            
            const receiptId = transaction_id?.slice(-12) || Date.now().toString().slice(-12);
            const receiptDate = new Date().toLocaleDateString('en-US', {
              day: 'numeric',
              month: 'long',
              year: 'numeric',
            });
            
            const pdfBuffer = await generatePdfReceipt(
              receiptId,
              customer_email || user.email,
              receiptDate,
              tokensToAdd,
              description || `Payment for ${tokensToAdd} tokens`,
              amount ? parseInt(amount) : 0,
              currency || 'USD'
            );

            await transporter.sendMail({
              from: process.env.OUTBOX_EMAIL,
              to: customer_email || user.email,
              subject: `Receipt #${receiptId} - Nerbixa Token Purchase`,
              text: `Hi there,

We're excited to welcome you to Nerbixa ‚Äî thanks so much for your recent order on nerbixa.com!

You'll find your transaction receipt attached to this message. Be sure to keep it in case you need it later.

Transaction Details:
- Receipt ID: ${receiptId}
- Tokens Purchased: ${tokensToAdd}
- Amount: ${((amount ? parseInt(amount) : 0) / 100).toFixed(2)} ${currency || 'USD'}
- Date: ${receiptDate}

If you run into any issues, have questions about your token usage, or need guidance, our support team is just an email away at support@nerbixa.com. We're always ready to help.

We're honored to be part of your creative journey.

With appreciation,
The Nerbixa Team
nerbixa.com
support@nerbixa.com`,
              attachments: [
                {
                  filename: `receipt-${receiptId}.pdf`,
                  content: pdfBuffer,
                  contentType: 'application/pdf',
                },
              ],
            });
            
            console.log('‚úÖ Receipt email sent to:', customer_email || user.email);
          } catch (emailError) {
            console.error('‚ö†Ô∏è  Failed to send receipt email:', emailError);
            console.error('   Email error details:', emailError instanceof Error ? emailError.message : 'Unknown error');
            // Don't fail the webhook if email fails - payment is already processed
          }

          const processingTime = Date.now() - startTime;
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
          console.log('‚úÖ Payment processed successfully');
          console.log('Processing time:', processingTime, 'ms');
          console.log('User ID:', tracking_id);
          console.log('Transaction ID:', transaction_id);
          console.log('Tokens added:', tokensToAdd);
          console.log('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');

        } catch (dbError) {
          console.error('‚ùå Database transaction failed:', dbError);
          throw dbError;
        }

        break;

      case 'failed':
        console.log(`‚ùå Payment failed for order ${order_id}`);
        console.log('Error message:', error_message);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction, –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º User
        if (transaction_id) {
          await prismadb.transaction.create({
            data: {
              tracking_id: transaction_id,
              userId: tracking_id || null,
              status: 'failed',
              amount: amount ? parseInt(amount) : null,
              currency: currency || 'USD',
              description: description || 'Payment failed',
              type: type || 'payment',
              payment_method_type: payment_method_type || 'card',
              message: error_message || 'Payment failed',
              reason: error_message,
              webhookEventId: transaction_id,
            },
          });
          console.log('‚úÖ Failed transaction record created in Transaction table');
        }
        break;

      case 'pending':
        console.log(`‚è≥ Payment pending for order ${order_id}`);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction, –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º User
        if (transaction_id) {
          await prismadb.transaction.create({
            data: {
              tracking_id: transaction_id,
              userId: tracking_id || null,
              status: 'pending',
              amount: amount ? parseInt(amount) : null,
              currency: currency || 'USD',
              description: description || 'Payment pending',
              type: type || 'payment',
              payment_method_type: payment_method_type || 'card',
              message: message || 'Payment pending',
              webhookEventId: transaction_id,
            },
          });
          console.log('‚úÖ Pending transaction record created in Transaction table');
        }
        break;

      case 'canceled':
        console.log(`üö´ Payment canceled for order ${order_id}`);
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –¢–û–õ–¨–ö–û –≤ —Ç–∞–±–ª–∏—Ü—É Transaction, –ù–ï –æ–±–Ω–æ–≤–ª—è–µ–º User
        if (transaction_id) {
          await prismadb.transaction.create({
            data: {
              tracking_id: transaction_id,
              userId: tracking_id || null,
              status: 'canceled',
              amount: amount ? parseInt(amount) : null,
              currency: currency || 'USD',
              description: description || 'Payment canceled',
              type: type || 'payment',
              payment_method_type: payment_method_type || 'card',
              message: message || 'Payment canceled',
              webhookEventId: transaction_id,
            },
          });
          console.log('‚úÖ Canceled transaction record created in Transaction table');
        }
        break;

      case 'refunded':
        console.log(`üí∞ Payment refunded for order ${order_id}`);
        
        if (transaction_id && tracking_id) {
          // –ò–∑–≤–ª–µ–∫–∞–µ–º –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ–∫–µ–Ω–æ–≤ –¥–ª—è –≤–æ–∑–≤—Ä–∞—Ç–∞
          const tokensToRefund = description ? extractTokensFromDescription(description) : null;
          
          if (tokensToRefund) {
            // –û–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ–º –≤–æ–∑–≤—Ä–∞—Ç –≤ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
            await prismadb.$transaction(async (tx) => {
              // 1. –°–æ–∑–¥–∞–µ–º –∑–∞–ø–∏—Å—å –æ –≤–æ–∑–≤—Ä–∞—Ç–µ –≤ Transaction table
              await tx.transaction.create({
                data: {
                  tracking_id: transaction_id,
                  userId: tracking_id,
                  status: 'refunded',
                  amount: amount ? parseInt(amount) : null,
                  currency: currency || 'USD',
                  description: description || 'Payment refunded',
                  type: 'refund',
                  payment_method_type: payment_method_type || 'card',
                  message: message || 'Payment refunded',
                  webhookEventId: transaction_id,
                },
              });
              console.log('‚úÖ Refund transaction record created in Transaction table');

              // 2. –í—ã—á–∏—Ç–∞–µ–º —Ç–æ–∫–µ–Ω—ã –∏–∑ –±–∞–ª–∞–Ω—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è (–¢–û–õ–¨–ö–û –æ–±–Ω–æ–≤–ª–µ–Ω–∏–µ –±–∞–ª–∞–Ω—Å–∞)
              const user = await tx.user.findUnique({
                where: { clerkId: tracking_id },
                select: { availableGenerations: true }
              });

              if (user) {
                await tx.user.update({
                  where: { clerkId: tracking_id },
                  data: {
                    // –í—ã—á–∏—Ç–∞–µ–º –≤–æ–∑–≤—Ä–∞—â–µ–Ω–Ω—ã–µ —Ç–æ–∫–µ–Ω—ã, –Ω–æ –Ω–µ —É—Ö–æ–¥–∏–º –≤ –º–∏–Ω—É—Å
                    availableGenerations: Math.max(0, user.availableGenerations - tokensToRefund),
                  },
                });
                console.log('‚úÖ User balance adjusted for refund in User table');
                console.log('   Tokens refunded:', tokensToRefund);
                console.log('   New balance:', Math.max(0, user.availableGenerations - tokensToRefund));
              }
            });
          }
        }
        break;

      default:
        console.log(`‚ùì Unknown payment status: ${status} for order ${order_id}`);
    }

    // –í–æ–∑–≤—Ä–∞—â–∞–µ–º —É—Å–ø–µ—à–Ω—ã–π –æ—Ç–≤–µ—Ç —Å–æ–≥–ª–∞—Å–Ω–æ —Ç—Ä–µ–±–æ–≤–∞–Ω–∏—è–º Networx
    return NextResponse.json({ status: 'ok' }, { status: 200 });

  } catch (error) {
    const processingTime = Date.now() - startTime;
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    console.error('‚ùå Webhook Processing Error');
    console.error('Timestamp:', new Date().toISOString());
    console.error('Processing time:', processingTime, 'ms');
    console.error('Transaction ID:', transactionId);
    console.error('User ID:', userId);
    console.error('Error:', error);
    console.error('Stack:', error instanceof Error ? error.stack : 'No stack trace');
    console.error('‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê');
    
    return NextResponse.json(
      { error: 'Webhook processing failed' },
      { status: 500 }
    );
  }
}

// GET - –î–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –¥–æ—Å—Ç—É–ø–Ω–æ—Å—Ç–∏ endpoint'–∞
export async function GET() {
  return NextResponse.json({
    message: 'Networx webhook endpoint is active',
    timestamp: new Date().toISOString(),
  });
}
